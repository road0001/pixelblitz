/**
* PixelBlitz Engine - BlitzMath
* @link http://www.pixelblitz.org
* @author Richard Davey / Photon Storm
*/

package pixelblitz.utils 
{
	/**
	 * The BlitzMath utility class adds a set of extremely fast (or extended) math functions to AS3
	 */
	public class BlitzMath 
	{
		public var getrandmax:int = int.MAX_VALUE;
		private var mr:uint = 0;
		private var cosTable:Array;
		private var sinTable:Array;
		
		private static const RADTODEG:Number = 180 / Math.PI;
		private static const DEGTORAD:Number = Math.PI / 180;
		
		public function BlitzMath()
		{
		}

		/**
		 * Experimental - Much faster version of v % d only for when d is any power of 2
		 * @param value The amount to divide
		 * @param divisor The divisor, must be a power of 2
		 * @return The remainder
		 */
		public function powerOf2mod(value:uint, divisor:uint):uint
		{
			return value & (divisor - 1);
		}
		
		//	Experimental iseven check
		public function isEven(value:Number):Boolean
		{
			return (value & 1) == 0;
		}
		
		//	Experimental abs replacement
		public function abs(value:int):int
		{
			return (value ^ (value >> 31)) - (value >> 31);
		}
		
		/**
		 * Generate a sine and cosine table simultaneously and extremely quickly. Based on research by Franky of scene.at
		 * <p>
		 * The parameters allow you to specify the length, amplitude and frequency of the wave. Once you have called this function
		 * you should get the results via getSinTable() and getCosTable(). This generator is fast enough to be used in real-time.
		 * </p>
		 * @param length The length of the wave
		 * @param sinAmplitude The amplitude to apply to the sine table (default 1.0) if you need values between say -+ 125 then give 125 as the value
		 * @param cosAmplitude The amplitude to apply to the cosine table (default 1.0) if you need values between say -+ 125 then give 125 as the value
		 * @param frequency The frequency of the sine and cosine table data
		 * @see getSinTable
		 * @see getCosTable
		 */
		public function sinCosGenerator(length:uint, sinAmplitude:Number = 1.0, cosAmplitude:Number = 1.0, frequency:Number = 1.0):void
		{
			var sin:Number = sinAmplitude;
			var cos:Number = cosAmplitude;
			var frq:Number = frequency * Math.PI / length;
			
			cosTable = new Array();
			sinTable = new Array();
			
			for (var c:uint = 0; c < length; c++)
			{
				cos -= sin * frq;
				sin += cos * frq;
				
				cosTable.push(cos);
				sinTable.push(sin);
			}
		}
		
		/**
		 * Returns the sine table generated by sinCosGenerator(), or an empty array object if not yet populated
		 * @return Array of sine wave data
		 * @see sinCosGenerator
		 */
		public function getSinTable():Array
		{
			return sinTable;
		}
		
		/**
		 * Returns the cosine table generated by sinCosGenerator(), or an empty array object if not yet populated
		 * @return Array of cosine wave data
		 * @see sinCosGenerator
		 */
		public function getCosTable():Array
		{
			return cosTable;
		}
		
		/**
		 * A faster version of Math.sqrt
		 * <p>
		 * Computes and returns the square root of the specified number.
		 * </p>
		 * @link http://osflash.org/as3_speed_optimizations#as3_speed_tests
		 * @param val A number greater than or equal to 0
		 * @return If the parameter val is greater than or equal to zero, a number; otherwise NaN (not a number).
		 */
		public function sqrt(val:Number):Number
		{
			if (isNaN(val))
			{
				return NaN;
			}
			
			var thresh:Number = 0.002;
			var b:Number = val * 0.25;
			var a:Number;
			var c:Number;
			
			if (val == 0)
			{
				return 0;
			}
			
			do {
				c = val / b;
				b = (b + c) * 0.5;
				a = b - c;
				if (a < 0) a = -a;
			}
			while (a > thresh);
			
			return b;
		}
		
		/**
		 * Generates a small random number between 0 and 65535 very quickly
		 * <p>
		 * Generates a small random number between 0 and 65535 using an extremely fast cyclical generator, 
		 * with an even spread of numbers. After the 65536th call to this function the value resets.
		 * </p>
		 * @return A pseudo random value between 0 and 65536 inclusive.
		 */
		public function miniRand():int
		{
			var result:uint = mr;
			
			result++;
			result *= 75;
			result %= 65537;
			result--;
			
			mr++;
			
			if (mr == 65536)
			{
				mr = 0;
			}
			
			return result;
		}
		
		/**
		 * Generate a random integer
		 * <p>
		 * If called without the optional min, max arguments rand() returns a peudo-random integer between 0 and getrandmax().
		 * If you want a random number between 5 and 15, for example, (inclusive) use rand(5, 15)
		 * Parameter order is insignificant, the return will always be between the lowest and highest value.
		 * </p>
		 * @param min The lowest value to return (default: 0)
		 * @param max The highest value to return (default: getrandmax)
		 * @return A pseudo-random value between min (or 0) and max (or getrandmax, inclusive)
		 */
		public function rand(min:Number = NaN, max:Number = NaN):int
		{
			if (isNaN(min))
			{
				min = 0;
			}
			
			if (isNaN(max))
			{
				max = getrandmax;
			}
			
			if (min === max)
			{
				return min;
			}
			else if (min < max)
			{
				return min + (Math.random() * max);
			}
			else
			{
				return max + (Math.random() * min);
			}
		}
		
		/**
		 * Generate a random float (number)
		 * <p>
		 * If called without the optional min, max arguments rand() returns a peudo-random float between 0 and getrandmax().
		 * If you want a random number between 5 and 15, for example, (inclusive) use rand(5, 15)
		 * Parameter order is insignificant, the return will always be between the lowest and highest value.
		 * </p>
		 * @param min The lowest value to return (default: 0)
		 * @param max The highest value to return (default: getrandmax)
		 * @return A pseudo random value between min (or 0) and max (or getrandmax, inclusive)
		 */
		public function randFloat(min:Number = NaN, max:Number = NaN):Number
		{
			if (isNaN(min))
			{
				min = 0;
			}
			
			if (isNaN(max))
			{
				max = getrandmax;
			}
			
			if (min === max)
			{
				return min;
			}
			else if (min < max)
			{
				return min + (Math.random() * max);
			}
			else
			{
				return max + (Math.random() * min);
			}
		}
		
		/**
		 * Generate a random boolean result based on the chance value
		 * <p>
		 * Returns true or false based on the chance value (default 50%). For example if you wanted a player to have a 30% chance
		 * of getting a bonus, call chanceRoll(30) - true means the chance passed, false means it failed.
		 * </p>
		 * @param chance The chance of receiving the value. Should be given as a uint between 0 and 100 (effectively 0% to 100%)
		 * @return true if the roll passed, or false
		 */
		public function chanceRoll(chance:uint = 50):Boolean
		{
			if (chance <= 0)
			{
				return false;
			}
			else if (chance >= 100)
			{
				return true;
			}
			else
			{
				if (Math.random() * 100 >= chance)
				{
					return true;
				}
				else
				{
					return false;
				}
			}
		}
		
		/**
		 * Converts a Radian value into a Degree
		 * <p>
		 * Converts the radians value into degrees and returns
		 * </p>
		 * @param radians The value in radians
		 * @return Number Degrees
		 */
		public function asDegrees( radians:Number ):Number
		{
			return radians * RADTODEG;
		}
		
		/**
		 * Converts a Degrees value into a Radian
		 * <p>
		 * Converts the degrees value into radians and returns
		 * </p>
		 * @param degrees The value in degrees
		 * @return Number Radians
		 */
		public function asRadians( degrees:Number ):Number
		{
			return degrees * DEGTORAD;
		}
		
		
	}
}