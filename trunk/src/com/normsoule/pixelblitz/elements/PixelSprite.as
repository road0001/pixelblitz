package com.normsoule.pixelblitz.elements{	import com.normsoule.pixelblitz.PixelBlitz;	import com.normsoule.pixelblitz.layers.RenderLayer;	import com.normsoule.pixelblitz.utils.FastMath;	import flash.display.Bitmap;	import flash.display.BitmapData;	import flash.display.DisplayObject;	import flash.events.EventDispatcher;	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.geom.Matrix;	import flash.utils.getQualifiedClassName;	/**	 * The PixelSprite class is the base class for all classes that	 *  can be added to a render layer and be rendered.	 * <p>	 * The PixelSprite class is very similar to the Sprite class but, in bitmap form.	 * Rotation, alpha, and scale are currently not supported.	 * </p>	 */	public dynamic class PixelSprite extends EventDispatcher	{		/**		 * @private		 */		protected const ZERO_POINT:Point = new Point();				/**		 * @private		 */		private var fastMath:FastMath = new FastMath();				/**		 * @private		 */		protected var _layer:RenderLayer;				/**		 * @private		 */		protected var collisionRect:Rectangle = new Rectangle();				/**		 * The horizontal position in pixels of the PixelSprite instance.		 */		public var x:Number 	= 0;				/**		 * The vertical position in pixels of the PixelSprite instance.		 */		public var y:Number 	= 0;				/**		 * The width in pixels of the PixelSprite instance.		 */		public var width:int 	= 0;				/**		 * The height in pixels of the PixelSprite instance.		 */		public var height:int 	= 0;				/**		 * The top (Y pixel coordinate) of the PixelSprite instance.		 */		public var top:int 	= 0;				/**		 * The bottom (Y + Height pixel coordinate) of the PixelSprite instance.		 */		public var bottom:int 	= 0;				/**		 * The left (X pixel coordinate) of the PixelSprite instance.		 */		public var left:int 	= 0;				/**		 * The right (X + Width pixel coordinate) of the PixelSprite instance.		 */		public var right:int 	= 0;				/**		 * The horizontal scale applied to this PixelSprite instance		 */		private var sx:Number 	= 0;				/**		 * The vertical scale applied to this PixelSprite instance		 */		private var sy:Number 	= 0;				/**		 * The visibility state of this PixelSprite instance (true = will be drawn by the Renderer)		 */		private var willRender:Boolean = true;				/**		 * The BitmapData object that will be rendered to the RenderLayer this object has been added to.		 */		public var bitmapData:BitmapData;				/**		 * The BitmapData object rect property.		 */		public var rect:Rectangle;				/**		 * Creates a PixelSprite instance.		 * <p>		 * Parses the supplied DisplayObject and converts the first frame of animation to a virtual frame.		 * The DisplayObject is drawn to a bitmapData object with the width and height of the 		 * DisplayObject defining the width and height of the BitmapData object.		 * </p>		 * @param displayObject The DisplayObject instance to convert into a PixelSprite object.		 */		public function PixelSprite( displayObject:DisplayObject )		{  			parseClip( displayObject );						rect 	= bitmapData.rect;			width 	= bitmapData.width;			height 	= bitmapData.height;			top 	= y;			bottom 	= y + height;			left 	= x;			right 	= x + width;		}				/**		 * @private		 * Parses the supplied DisplayObject and converts each frame of animation to a virtual frame.		 * @param displayObject The displayObject to convert.		 */		protected function parseClip( displayObject:DisplayObject ):void		{			var id:String = getQualifiedClassName( displayObject ) + "_" + 1;						//	Check if it is already in the collection (except for Bitmaps)			if ( PixelBlitz.bmdCollection.search( id ) && !displayObject is Bitmap )			{				bitmapData = PixelBlitz.bmdCollection.collection[ id ];			}			else			{				// create a new bitmapData object to draw on				var bmd:BitmapData = new BitmapData( displayObject.width, displayObject.height, true, 0x0 );								//	Does the Display Object have any scaling or rotation applied to it?				if (displayObject.scaleX != 1 || displayObject.scaleY != 1 || displayObject.rotation != 0)				{					var matrix:Matrix = new Matrix();										matrix.scale(displayObject.scaleX, displayObject.scaleY);										bmd.draw( displayObject, matrix );				}				else				{					bmd.draw( displayObject );				}										// add the bitmapData to the collection				bitmapData = PixelBlitz.bmdCollection.addBitmapData( id, bmd );			}		}				/**		 * @private		 */		public function set layer( value:RenderLayer ):void		{			_layer = value;		}				/**		 * The depth or z-order of the PixelSprite instance.		 */		public function get depth():int		{			return _layer.getDepth( this );			}		/**		 * Returns the distance (in pixels) between the two PixelSprite objects.		 * <p> 		 * This returns the distance in pixels between the X/Y of the current and given PixelSprite objects.		 * </p>		 * @param object The PixelSprite instance to test against.		 * @param round Should the resulting distance be rounded to a whole number?		 * @return Returns a number value for the distance in pixels		 * @example 		 * <code>		 * if ( obj1.getDistance( obj2 ) < 100 )		 * {		 * 		trace("objects are within 100 pixels of each other");		 * }		 * </code>		 */		public function getDistance( object:PixelSprite, round:Boolean = true ):Number		{			var dx:Number = object.x - x;			var dy:Number = object.y - y;			var distance:Number = fastMath.sqrt(dx * dx + dy * dy);						if (round)			{				return Math.round(distance);			}			else			{				return distance;			}		}				/**		 * Performs a fast box based collision check against the supplied PixelSprite object.		 * <p> 		 * This is a fast bounding box collision test that will always catch the rectangular collision of 2 PixelSprite objects,		 * no matter what size or placement they have		 * </p>		 * @param object The PixelSprite instance to test against.		 * @return Returns a boolean value indicating if a collision occured.		 * @example 		 * <code>		 * if ( obj1.getBoxCollision( obj2 ) )		 * {		 * 		trace("collision occured");		 * }		 * </code>		 */		public function getBoxCollision( object:PixelSprite ):Boolean		{			if ( !( top > object.bottom || bottom < object.top || left > object.right || right < object.left ) )			{				return true;			}			else			{				return false;			}		}				/**		 * Performs a pixel-level collision check against the supplied PixelSprite object.		 * <p> 		 * This is a shape based collision test versus the standard DisplayObject bounding box <code>hitTestObject</code>.		 * The collision check compares the alpha value of each pixel. 		 * </p>		 * @param object The PixelSprite instance to test against.		 * @return Returns a boolean value indicating if a collision occured.		 * @example 		 * <code>		 * if ( obj1.getCollision( obj2 ) )		 * {		 * 		trace("collision occured");		 * }		 * </code>		 */		public function getCollision( object:PixelSprite ):Boolean		{			if ( bitmapData.hitTest( new Point(x, y), 1, object.bitmapData, new Point( object.x, object.y), 1 ) )			{				return true;			}			return false;		}				/**		 * Checks if the supplied point is inside of the PixelSprite object.		 * <p>		 * This method is useful for mouse detection where the point is the mouse x and y properties.		 * </p>		 * @param point The Point to test against.		 * @return A boolean value indicating if a collision occured.		 */		public function getCollisionPoint( point:Point ):Boolean		{			collisionRect.x = (x + PixelBlitz.camera2D.basePoint.x) * _layer.parallax;			collisionRect.y = (y + PixelBlitz.camera2D.basePoint.y) * _layer.parallax;			collisionRect.width = width;			collisionRect.height = height;						if ( collisionRect.containsPoint( point ) )			{				return true;			}						return false;		}				/**		 * Indicates the horizontal scale (percentage) of the object as applied from the registration point.		 * @param value The amount to scale horizontally by		 * @see scaleY		 */		public function set scaleX(value:Number):void		{			scale(value, 1);		}				/**		 * Indicates the horizontal scale (percentage) of the object as applied from the registration point.		 * @see scaleY		 */		public function get scaleX():Number		{			return sx;		}				/**		 * Indicates the vertical scale (percentage) of the object as applied from the registration point.		 * @param value The amount to scale vertically by		 * @see scaleX		 */		public function set scaleY(value:Number):void		{			scale(1, value);		}				/**		 * Indicates the vertical scale (percentage) of the object as applied from the registration point.		 * @see scaleX		 */		public function get scaleY():Number		{			return sy;		}				/**		 * Sets the horizontal and vertical scale (percentage) of the object together, as applied from the registration point.		 * @param _sx The amount to scale horizontally by		 * @param _sy The amount to scale vertically by		 */		public function scale(_sx:Number, _sy:Number):void		{			var matrix:Matrix = new Matrix();						matrix.scale(_sx, _sy);						//	In order to scale this bmd we create a temporary home for it first						var scaledBitmapData:BitmapData = new BitmapData(width * _sx, height * _sy, true, 0x0);						scaledBitmapData.draw( bitmapData, matrix );						bitmapData = scaledBitmapData.clone();						//	We're done with the temp. version			scaledBitmapData.dispose();						//	Update this objects properties			sx = _sx;			sy = _sy;			update();		}				/**		 * Indicates the visibility of this object (invisible objects are not processed by the renderer)		 * @param state boolean		 */		public function set visible(state:Boolean):void		{			willRender = state;		}				/**		 * Indicates the visibility of this object (invisible objects are not processed by the renderer)		 */		public function get visible():Boolean		{			return willRender;		}				/**		 * Removes the PixelSprite from the RenderLayer it is registered to.		 * The dispose method also clears the internal data making it available for Garbage Collection.		 * All external refferences should be set to null as well to ensure it will be available for Garbage Collection.		 */		public function dispose():void		{			bitmapData = null;			_layer.removeItem( this );		}				/**		 * @private		 */		public function update():void 		{			rect 	= bitmapData.rect;			width 	= bitmapData.width;			height 	= bitmapData.height;			top 	= y;			bottom 	= y + height;			left 	= x;			right 	= x + width;		}	}}